<?php
include_once("../templates/template_functions.php");
page_header("deep_dives", "calculating_square_roots.html", "Calculating square roots", "Calculating square roots", "A deep dive into calculating square roots in Elite on the 6502", "elite", "deep_dives_maths", "calculating_square_roots");
?>
				<div class="codeBlockWrapper nav">
					<nav class="codeBlock previousNext"><a class="previous" rel="prev" title="Previous deep dive" href="adding_sign-magnitude_numbers.html">Adding sign-magnitude numbers</a><a class="next" rel="next" title="Next deep dive" href="shift-and-add_multiplication.html">Shift-and-add multiplication</a></nav>
				</div>

				<div class="codeBlockWrapper">
					<div class="codeBlock article">
						<h2 class="articleSubheader deepDive">The algorithm behind the square root routine</h2>

						<p>The algorithm used to calculate square roots in routine <a href="/cassette/main/subroutine/ll5.html">LL5</a> is related to the division algorithm in TIS2 (see the deep dive on <a href="shift-and-subtract_division.html">shift-and-subtract division</a> for details), though with a couple of twists. If you think about the division algorithm, it calculates the quotient and remainder from a given dividend and divisor, and the following holds:</p>

<pre class="articleIndented">  dividend = (quotient * divisor) + remainder
</pre>

						<p>The problem of calculating the square root is related to this, except we have the following relationship between the arguments and results, where "number" is the number we want to find the square root of:</p>

<pre class="articleIndented">  number = (root * root) + remainder
</pre>

						<p>So the number we want to find the root of is equivalent to the dividend in the shift-and-subtract algorithm, and instead of the divisor being fixed, we instead build up the root bit by bit and use that in place of the divisor.</p>

						<p>When generalised to calculate the n-th root, this approach is called the "shifting nth-root" algorithm, and it is explained in various places on the web by minds more devious than mine. The LL5 routine is an application of the algorithm for n = 2, which is why the number ("dividend") and remainder get shifted by two places in each iteration.</p>

						<p>There is a deeper explanation of this exact routine here, though I have to say it makes my head spin more than a little:</p>

<pre class="articleIndented">   <a href="http://6502org.wikidot.com/software-math-sqrt">http://6502org.wikidot.com/software-math-sqrt</a>
</pre>

						<p>It also turns out that the LL5 routine in Elite is identical to the SQR16 routine from the <a href="https://archive.org/details/PersonalComputerWorld1983-03/page/186/mode/1up">March 1983 issue of Personal Computer World</a>. The same routine also appears in the book <a href="https://archive.org/details/assembler-routines-for-the-6502/page/126/mode/2up">Assembler Routines for the 6502</a> by Dave Barrow. Thanks to TobyLobster and Rocketeer for some top-tier detective work in tracking this down - see <a href="https://stardot.org.uk/forums/viewtopic.php?p=349165#p349165">this thread from Stardot</a> for more details.</p>

						<p>This algorithm is definitely one for the "must study later" pile...</p>
					</div>
				</div>

				<div class="codeBlockWrapper nav">
					<nav class="codeBlock previousNext"><a class="previous" rel="prev" title="Previous deep dive" href="adding_sign-magnitude_numbers.html">Adding sign-magnitude numbers</a><a class="next" rel="next" title="Next deep dive" href="shift-and-add_multiplication.html">Shift-and-add multiplication</a></nav>
				</div>
			</article>

<?php
include_once("../templates_local/navigation.php");
?>
		</div>
	</body>
</html>
