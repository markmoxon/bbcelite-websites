<?php
include_once("../templates/template_functions.php");
page_header("deep_dives", "in_david_brabens_own_words.html", "In David Braben's own words", "In David Braben's own words", "A deep dive into an article by David Braben about Lander in The Micro User", "lander", "deep_dives_miscellaneous", "in_david_brabens_own_words");
?>
				<div class="codeBlockWrapper nav">
					<nav class="codeBlock previousNext"><a class="previous" rel="prev" title="Previous page" href="random_numbers.html">Random numbers</a><a class="next" rel="next" title="Next page" href="comparing_lander_to_zarch.html">Comparing Lander to Zarch</a></nav>
				</div>

				<div class="codeBlockWrapper">
					<div class="codeBlock article">
						<h2 class="articleSubheader deepDive">A code analysis of the Lander author's own article from The Micro User</h2>

						<p>Sometimes when you tackle a big disassembly project, you're not the first to go there; for example, when I documented Elite, there were <a href="https://elite.bbcelite.com/about_site/about_this_project.html">plenty of other people</a> who had already documented aspects of the game, so I didn't go into it completely blind. On the other side of the coin, <a href="https://revs.bbcelite.com/">Revs</a> was a lot more challenging as I couldn't find anything at all to help me along, so I had to work out everything from scratch.</p>

						<p>There wasn't much information available for <a href="https://aviator.bbcelite.com/">Aviator</a> or Lander either, but both of these games came with an incredibly valuable set of clues, straight from the authors themselves. Aviator's game manual contains a <a href="https://aviator.bbcelite.com/deep_dives/matching_the_code_to_the_flight_model.html">full specification of the flight model</a>, which turned out to be incredibly useful when analysing that part of the code; and although the "manual" for Lander is little more than a few words in the Archimedes application guide, there's a fantastic magazine article in the November 1987 edition of The Micro User that more than makes up for it. It even made the cover:</p>

						<img class="titleImage photo" style="width: 250px" src="/images/deep_dives/micro_user/november_1987_cover.jpg" alt="The cover of The Micro User, November 1987">

						<p>Written by none other than David Braben himself, this article is a run-down of all of Lander's main technical achievements, plus the extra features that make Zarch an even more impressive sequel. It is an absolute goldmine for anyone wanting to understand how Lander and Zarch work; you can read the <a href="https://archive.org/details/micro-user-057/page/n15/mode/1up">article on archive.org</a>, and I can highly recommend it.</p>

						<p>In the table below, I'll quote the main points of interest from this article, and link to the relevant bits of the source code, and any deep dives that explain things in more detail. So not only can you read David Braben's descriptions of this epic game, but you can follow along with the relevant source code as well.</p>

						<table class="spacedTableBorder codeSummary">
							<tr class="codeSummaryHeader"><th>Quote</th><th style="width: 45%">Details</th></tr>
							<tr><td><p>"Also speed considerations restricted the direction of view to a constant (to avoid the overhead of additional rotating and clipping), although on very early versions of the game this was not the case (this code was used to produce the Union Jack demo, which can rotate about any axis)."</p></td><td><ul><li>Deep dive: <a href="unused_code_in_lander.html">Unused code in Lander</a></li><li>Code: <a href="/source/main/subroutine/transposerotationmatrix.html">TransposeRotationMatrix</a></li></ul></td></tr>
							<tr><td><p>"With the display technique chosen, the frame rate dictated the approximate number of tiles which could be used and also the amount of scenery. The display looks much better if these are greatly increased - as the picture on this page shows - but sadly this reduces the frame rate to only one or two frames per second - a succession of stills."</p></td><td><ul><li>Configuration variables: TILES_X and TILES_Z</li></ul></td></tr>
							<tr><td><p>"To avoid flickering bank-switching, which uses two screens with all plotting being done to the hidden one, is used. They are switched when a frame is finished. However, this requires twice as much screen memory."</p></td><td><ul><li>Deep dive: <a href="screen_memory_in_the_archimedes.html">Screen memory in the Archimedes</a></li><li>Code: <a href="/source/main/subroutine/switchscreenbank.html">SwitchScreenBank</a></li></ul></td></tr>
							<tr><td><p>"Both Lander and Zarch use Mode 13, a 256 colour equivalent of Mode 1. There was almost no choice as to the screen mode to use, since 256 colours gives the required scope for shading and lighting, and there is no (hardware) lower resolution with this number of colours available."</p></td><td><ul><li>Deep dive: <a href="screen_memory_in_the_archimedes.html">Screen memory in the Archimedes</a></li><li>Code: <a href="/source/main/subroutine/entry.html">Entry</a></li></ul></td></tr>
							<tr><td><p>"The graphics on Zarch and Lander are quite simple. The hidden line removal routine uses an Elite-like method to filter out some of the triangles..."</p></td><td><ul><li>Deep dive: <a href="drawing_3d_objects.html">Drawing 3D objects</a> (section "The DrawObject routine")</li><li>Code: <a href="/source/main/subroutine/drawobject_part_5_of_5.html">DrawObject (Part 5 of 5)</a></li></ul></td></tr>
							<tr><td><p>"...and then depth sorts all the graphic elements, including particles before plotting them. This means that shapes go in front of each other in the correct fashion.<br><br>The best general sorting algorithms such as quicksort, take of order n log(n) steps, and are still a bit slow. However, since objects only need to be approximately in order, and it is known that the values are in a certain range, a technique known as bin sorting is used.<br><br>This involves having a buffer for each of a range of depth values, and when an object's position is calculated it is put into the relevant buffer. Finally the buffers are flushed in depth order, farthest first. This requires a great deal of memory, but is virtually free as far as time considerations go."</p></td><td><ul><li>Deep dive: <a href="depth-sorting_with_the_graphics_buffers.html">Depth-sorting with the graphics buffers</a></li><li>Code: <a href="/source/main/subroutine/drawgraphicsbuffer.html">DrawGraphicsBuffer</a></li></ul></td></tr>
							<tr><td><p>"Another technique used is colour keying the depth. This is clearly trivial, but gives a good effect and is achieved by varying levels of white according to the depth of an object in the screen.<br><br>This is actually not what would be seen - colour tends to be lost in the distance - but is more effective than the rounding towards grey that might be expected. With only 256 colours the steps seem more blatant with, for example, red suddenly becoming grey."</p></td><td><ul><li>Deep dive: <a href="drawing_the_landscape.html">Drawing the landscape</a> (section "Tile colours")</li><li>Code: <a href="/source/main/subroutine/getlandscapetilecolour.html">GetLandscapeTileColour</a></li></ul></td></tr>
							<tr><td><p>"Shadows are almost essential; it is surprisingly hard to judge height without them. They are also quite easy to simulate if you are allowed a little artistic licence. Firstly each node of each shape is projected on to the landscape vertically, for speed, then they are projected to the screen in the normal fashion, and joined up with black triangles.<br><br>This method is clearly incorrect since it does not allow for the curve of the landscape, nor does it allow for scenery - no, shadows don't go over houses or other shapes."</p></td><td><ul><li>Deep dive: <a href="drawing_3d_objects.html">Drawing 3D objects</a> (section "Drawing object shadows")</li><li>Code: <a href="/source/main/subroutine/drawobject_part_4_of_5.html">DrawObject (Part 4 of 5)</a></li></ul></td></tr>
							<tr><td><p>"All shapes are lit from above and slightly to the left to give a better 3D effect, and to emphasise the shadows. This is done by calculating the angle between a light ray and each face of the shape. The brightness of the face is then some function of that angle. Lander and Zarch use:<br><br>Brightness = k * SIN(angle)<br><br>FaceColour = BaseColour + Brightness * White<br><br>Where k is the number of shades available for lighting, and White is the smallest amount of white available."</p></td><td><ul><li>The dot product calculates the SIN(angle) part, which is then used to set the face colour</li><li>Deep dive: <a href="drawing_3d_objects.html">Drawing 3D objects</a> (section "Dot product")</li><li>Code: <a href="/source/main/subroutine/drawobject_part_3_of_5.html">DrawObject (Part 3 of 5)</a></li></ul></td></tr>
							<tr><td><p>"The object routine has a list of objects, each of which have a list of attributes including position, velocity and a driving routine pointer. This makes the code very simple indeed."</p></td><td><ul><li>The object system is a lot simpler in Lander, and consists of a two-dimensional object map with static objects</li><li>Deep dive: <a href="placing_objects_on_the_map.html">Placing objects on the map</a></li><li>Code: <a href="/source/main/subroutine/placeobjectsonmap.html">PlaceObjectsOnMap</a></li></ul></td></tr>
							<tr><td><p>"The driving routines are called every game cycle for each object, and these routines, different for each object type, take care of the behaviour of that object. This leaves the object routine loop to do such things common to all as plotting and hit checking."</p></td><td><ul><li>There are no driving routines in Lander, apart from the falling rocks, which are implemented as particles</li><li>Deep dive: <a href="particles_and_particle_clouds.html">Particles and particle clouds</a></li><li>Code: <a href="/source/main/subroutine/moveanddrawparticles_part_1_of_4.html">MoveAndDrawParticles</a></li></ul></td></tr>
							<tr><td><p>"The particle routine, although similar in principle to the object routine, has more compact data, and rather than call a routine for each particle, each has a flags word with each bit determining some aspect of its behaviour."</p></td><td><ul><li>Deep dive: <a href="particles_and_particle_clouds.html">Particles and particle clouds</a></li><li>Code: <a href="/source/main/subroutine/moveanddrawparticles_part_1_of_4.html">MoveAndDrawParticles</a></li></ul></td></tr>
							<tr><td><p>"The landscape routine obtains the rolling hillside effect by simply adding a set of pseudo-random sine waves, which are clipped at a fixed height to give the water. As a look-up table is used to calculate the sine values, this technique is very fast."</p></td><td><ul><li>Deep dive: <a href="generating_the_landscape.html">Generating the landscape</a></li><li>Code: <a href="/source/main/subroutine/getlandscapealtitude.html">GetLandscapeAltitude</a></li></ul></td></tr>
							<tr><td><p>"The landscape is a bit too uniform without the water, which of course is very easy to add."</p></td><td><ul><li>Deep dive: <a href="generating_the_landscape.html">Generating the landscape</a></li><li>Code: <a href="/source/main/subroutine/getlandscapealtitude.html">GetLandscapeAltitude</a></li></ul></td></tr>
							<tr><td><p>"[Talking about Zarch] It is very hard to play at first. The mouse controls are very different to other games, but once you get the hang of flying the craft it is quite satisfying - and there is scope for some fancy flying."</p></td><td><ul><li>Deep dive: <a href="flying_by_mouse.html">Flying by mouse</a></li><li>Code: <a href="/source/main/subroutine/moveanddrawplayer_part_1_of_5.html">MoveAndDrawPlayer</a></li></ul></td></tr>
							<tr><td><p>"[Talking about Zarch demo mode] This requires less than a screenful of ARM (Basic assembler) source code, admittedly using multi-statement lines (single statement lines are for people with shares in timber companies, or weenies who insist on writing a paragraph of comments on each instruction)."</p></td><td><ul><li>This entire documented source code project is an example of weenie code, I guess! My apologies... :-)</li></ul></td></tr>
						</table>
					</div>
				</div>

				<div class="codeBlockWrapper nav">
					<nav class="codeBlock previousNext"><a class="previous" rel="prev" title="Previous page" href="random_numbers.html">Random numbers</a><a class="next" rel="next" title="Next page" href="comparing_lander_to_zarch.html">Comparing Lander to Zarch</a></nav>
				</div>
			</article>

<?php
include_once("../templates_local/navigation.php");

?>
		</div>
	</body>
</html>
